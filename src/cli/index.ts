#!/usr/bin/env node

import { Command } from 'commander';
import chalk from 'chalk';
import ora from 'ora';
import { resolve } from 'node:path';
import { writeFile } from 'node:fs/promises';
import { analyzeRepository } from '../core/analyzer.js';
import { createRenderer } from '../outputs/index.js';
import { isGitRepository } from '../utils/exec.js';
import { createBurnoutAnalyzer } from '../analyzers/burnout-analyzer.js';
import { createLeaderboardAnalyzer } from '../analyzers/leaderboard-analyzer.js';
import { createDeadCodeAnalyzer } from '../analyzers/deadcode-analyzer.js';
import { createDependencyAnalyzer } from '../analyzers/dependency-analyzer.js';
import { createCopyPasteAnalyzer } from '../analyzers/copypaste-analyzer.js';
import { createCodeCityAnalyzer } from '../analyzers/codecity-analyzer.js';
import { createGitParser } from '../parsers/git-parser.js';
import { renderCodeCity3D } from '../outputs/city3d-renderer.js';
import {
  renderBurnoutHtml,
  renderLeaderboardHtml,
  renderDeadCodeHtml,
  renderDependencyHtml,
  renderDuplicatesHtml,
  renderVelocityHtml,
  renderBusFactorHtml,
  renderWorkPatternsHtml,
  renderComplexityHtml,
  renderCommitQualityHtml,
  renderCollaborationHtml,
  renderCouplingHtml,
  renderHealthHtml,
  renderBranchesHtml,
} from '../outputs/analyzer-html-renderers.js';
import type { AnalysisConfig, OutputFormat } from '../types/index.js';

// Helper to handle output for individual commands
// Always shows CLI output, and saves HTML if -f is provided
async function handleOutput<T>(
  data: T,
  options: { file?: string },
  cliFormatter: () => string,
  htmlGenerator?: (data: T) => string
): Promise<void> {
  // Always show CLI output
  console.log(cliFormatter());

  // If file specified, also save HTML
  if (options.file) {
    const htmlContent = htmlGenerator ? htmlGenerator(data) : generateStandaloneHtml(data);
    await writeFile(options.file, htmlContent);
    console.log(chalk.green(`\nüìÑ HTML saved to: ${options.file}`));
  }
}

// Generate standalone HTML for individual analyzer results
function generateStandaloneHtml<T>(data: T): string {
  return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GitStats Report</title>
  <style>
    :root { --bg: #1a1a2e; --card: #16213e; --text: #eaeaea; --text-secondary: #a0a0a0; --accent: #00d9ff; --success: #00ff88; --warning: #ffcc00; --danger: #ff4757; }
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, monospace; background: var(--bg); color: var(--text); padding: 2rem; line-height: 1.6; }
    .container { max-width: 1200px; margin: 0 auto; }
    h1 { color: var(--accent); margin-bottom: 1.5rem; }
    pre { background: var(--card); padding: 1.5rem; border-radius: 8px; overflow-x: auto; font-size: 0.9rem; white-space: pre-wrap; word-wrap: break-word; }
    .footer { margin-top: 2rem; text-align: center; color: var(--text-secondary); font-size: 0.85rem; }
  </style>
</head>
<body>
  <div class="container">
    <h1>GitStats Analysis</h1>
    <pre>${JSON.stringify(data, null, 2)}</pre>
    <div class="footer">Generated by GitStats ‚Ä¢ ${new Date().toISOString()}</div>
  </div>
</body>
</html>`;
}

const BANNER = `
   ${chalk.cyan('_____ _ _   _____ _        _')}
  ${chalk.cyan('/ ____(_) | / ____| |      | |')}
 ${chalk.cyan('| |  __ _| |_| (___ | |_ __ _| |_ ___')}
 ${chalk.cyan('| | |_ | | __|\\___ \\| __/ _\` | __/ __|')}
 ${chalk.cyan('| |__| | | |_ ____) | || (_| | |_\\__ \\')}
  ${chalk.cyan('\\_____|\\_\\__|_____/ \\__\\__,_|\\__|___/')}
                                    ${chalk.gray('v0.1.4')}
`;

function showBanner(): void {
  console.log(BANNER);
}

const program = new Command();

program
  .name('gitstats')
  .description('Powerful Git repository analyzer with comprehensive statistics')
  .version('0.1.3')
  .addHelpText('before', BANNER);

// Main analyze command
program
  .command('analyze')
  .description('Analyze a Git repository')
  .argument('[path]', 'Path to the repository', '.')
  .option('-f, --file <path>', 'Save HTML report to file')
  .option('-b, --branch <branch>', 'Analyze specific branch')
  .option('--since <date>', 'Only commits after this date (ISO format)')
  .option('--until <date>', 'Only commits before this date (ISO format)')
  .option('--author <author>', 'Filter by author (can be used multiple times)', collect, [])
  .option('--exclude <path>', 'Exclude paths (glob pattern, can be used multiple times)', collect, [])
  .option('--include <path>', 'Include only these paths (glob pattern)', collect, [])
  .option('--no-merges', 'Exclude merge commits')
  .option('--max-commits <n>', 'Maximum number of commits to analyze', parseInt)
  .option('--theme <theme>', 'Theme for HTML output (light, dark)', 'dark')
  .action(async (path: string, options) => {
    showBanner();
    const repoPath = resolve(path);

    // Validate repository
    const isRepo = await isGitRepository(repoPath);
    if (!isRepo) {
      console.error(chalk.red(`Error: Not a git repository: ${repoPath}`));
      process.exit(1);
    }

    const spinner = ora('Analyzing repository...').start();

    try {
      // Build config
      const config: AnalysisConfig = {
        repoPath,
        branch: options.branch,
        since: options.since ? new Date(options.since) : undefined,
        until: options.until ? new Date(options.until) : undefined,
        authors: options.author.length > 0 ? options.author : undefined,
        excludePaths: options.exclude.length > 0 ? options.exclude : undefined,
        includePaths: options.include.length > 0 ? options.include : undefined,
        excludeMerges: !options.merges,
        maxCommits: options.maxCommits,
      };

      // Run analysis
      const report = await analyzeRepository(config, (progress) => {
        spinner.text = `${progress.phase} (${progress.current}/${progress.total})`;
      });

      spinner.succeed('Analysis complete');

      // Always show CLI output
      const cliRenderer = createRenderer('cli');
      const cliOutput = await cliRenderer.render(report, {
        format: 'cli',
        options: { pretty: true },
      });
      console.log('\n' + cliOutput);

      // Save HTML if -f is provided
      if (options.file) {
        const htmlRenderer = createRenderer('html');
        const htmlOutput = await htmlRenderer.render(report, {
          format: 'html',
          options: {
            pretty: true,
            theme: options.theme,
          },
        });
        await htmlRenderer.save(htmlOutput, options.file);
        console.log(chalk.green(`\nüìÑ HTML saved to: ${options.file}`));
      }
    } catch (error) {
      spinner.fail('Analysis failed');
      console.error(chalk.red(`Error: ${(error as Error).message}`));
      process.exit(1);
    }
  });

// Quick summary command
program
  .command('summary')
  .description('Show quick summary of a repository')
  .argument('[path]', 'Path to the repository', '.')
  .action(async (path: string) => {
    showBanner();
    const repoPath = resolve(path);

    const isRepo = await isGitRepository(repoPath);
    if (!isRepo) {
      console.error(chalk.red(`Error: Not a git repository: ${repoPath}`));
      process.exit(1);
    }

    const spinner = ora('Fetching summary...').start();

    try {
      const report = await analyzeRepository({ repoPath });
      spinner.stop();

      console.log('');
      console.log(chalk.bold.cyan(`  ${report.repository.name}`));
      console.log(chalk.gray(`  ${'‚îÄ'.repeat(40)}`));
      console.log(`  ${chalk.bold('Commits:')}      ${report.summary.totalCommits.toLocaleString()}`);
      console.log(`  ${chalk.bold('Authors:')}      ${report.summary.totalAuthors}`);
      console.log(`  ${chalk.bold('Lines added:')}  ${chalk.green('+' + report.summary.totalAdditions.toLocaleString())}`);
      console.log(`  ${chalk.bold('Lines deleted:')} ${chalk.red('-' + report.summary.totalDeletions.toLocaleString())}`);
      console.log(`  ${chalk.bold('Bus factor:')}   ${report.busFactor.overall}`);
      console.log(`  ${chalk.bold('Age:')}          ${report.summary.repositoryAge} days`);
      console.log('');
    } catch (error) {
      spinner.fail('Failed');
      console.error(chalk.red(`Error: ${(error as Error).message}`));
      process.exit(1);
    }
  });

// Authors command
program
  .command('authors')
  .description('List contributors with stats')
  .argument('[path]', 'Path to the repository', '.')
  .option('-n, --top <n>', 'Show top N authors', parseInt, 10)
  .option('--sort <field>', 'Sort by field (commits, additions, deletions)', 'commits')
  .action(async (path: string, options) => {
    showBanner();
    const repoPath = resolve(path);

    const isRepo = await isGitRepository(repoPath);
    if (!isRepo) {
      console.error(chalk.red(`Error: Not a git repository: ${repoPath}`));
      process.exit(1);
    }

    const spinner = ora('Analyzing authors...').start();

    try {
      const report = await analyzeRepository({ repoPath });
      spinner.stop();

      let authors = [...report.authors];

      // Sort by specified field
      switch (options.sort) {
        case 'additions':
          authors.sort((a, b) => b.additions - a.additions);
          break;
        case 'deletions':
          authors.sort((a, b) => b.deletions - a.deletions);
          break;
        // commits is default
      }

      authors = authors.slice(0, options.top);

      console.log('');
      console.log(chalk.bold.cyan(`  Top ${options.top} Contributors`));
      console.log(chalk.gray(`  ${'‚îÄ'.repeat(60)}`));

      authors.forEach((author, i) => {
        const rank = (i + 1).toString().padStart(2);
        const name = author.author.name.substring(0, 25).padEnd(25);
        const commits = author.commits.toString().padStart(6);
        const additions = chalk.green(`+${author.additions.toLocaleString()}`);
        const deletions = chalk.red(`-${author.deletions.toLocaleString()}`);

        console.log(`  ${chalk.gray(rank)}. ${name} ${chalk.yellow(commits)} commits  ${additions} ${deletions}`);
      });

      console.log('');
    } catch (error) {
      spinner.fail('Failed');
      console.error(chalk.red(`Error: ${(error as Error).message}`));
      process.exit(1);
    }
  });

// Hotspots command
program
  .command('hotspots')
  .description('Show code hotspots (high churn files)')
  .argument('[path]', 'Path to the repository', '.')
  .option('-n, --top <n>', 'Show top N hotspots', parseInt, 15)
  .action(async (path: string, options) => {
    showBanner();
    const repoPath = resolve(path);

    const isRepo = await isGitRepository(repoPath);
    if (!isRepo) {
      console.error(chalk.red(`Error: Not a git repository: ${repoPath}`));
      process.exit(1);
    }

    const spinner = ora('Analyzing hotspots...').start();

    try {
      const report = await analyzeRepository({ repoPath });
      spinner.stop();

      const hotspots = report.hotspots.files.slice(0, options.top);

      console.log('');
      console.log(chalk.bold.red(`  üî• Code Hotspots (High Churn)`));
      console.log(chalk.gray(`  ${'‚îÄ'.repeat(60)}`));

      hotspots.forEach((file, i) => {
        const rank = (i + 1).toString().padStart(2);
        const path = file.path.length > 50 ? '...' + file.path.slice(-47) : file.path.padEnd(50);
        const commits = file.commits.toString().padStart(4);
        const churn = file.churnScore.toFixed(1).padStart(6);

        const churnColor = file.churnScore > 100 ? chalk.red :
                          file.churnScore > 50 ? chalk.yellow : chalk.green;

        console.log(`  ${chalk.gray(rank)}. ${path} ${chalk.gray(commits)} commits  ${churnColor(churn)} churn`);
      });

      // Directory hotspots
      if (report.hotspots.directoryHotspots && report.hotspots.directoryHotspots.length > 0) {
        console.log('');
        console.log(chalk.bold.yellow(`  üìÅ Directory Hotspots`));
        console.log(chalk.gray(`  ${'‚îÄ'.repeat(60)}`));

        report.hotspots.directoryHotspots.slice(0, 8).forEach(dir => {
          const riskColor = dir.riskLevel === 'critical' ? chalk.red :
                           dir.riskLevel === 'high' ? chalk.yellow :
                           dir.riskLevel === 'medium' ? chalk.cyan : chalk.green;
          const riskBadge = riskColor(`[${dir.riskLevel.toUpperCase()}]`);

          console.log(`    ${dir.path.padEnd(30)} ${riskBadge} ${dir.commits} commits, ${dir.fileCount} files`);
        });
      }

      // Risk map
      if (report.hotspots.riskMap && report.hotspots.riskMap.length > 0) {
        console.log('');
        console.log(chalk.bold.red(`  üéØ Risk Map (highest risk files)`));
        console.log(chalk.gray(`  ${'‚îÄ'.repeat(60)}`));

        report.hotspots.riskMap.slice(0, 5).forEach(entry => {
          const riskColor = entry.riskLevel === 'critical' ? chalk.red :
                           entry.riskLevel === 'high' ? chalk.yellow : chalk.cyan;
          const path = entry.path.length > 40 ? '...' + entry.path.slice(-37) : entry.path;

          console.log(`    ${riskColor('‚óè')} ${path.padEnd(42)} ${riskColor(`${entry.combinedRisk.toFixed(0)}%`)}`);
          console.log(`      ${chalk.gray(entry.recommendation)}`);
        });
      }

      console.log('');
    } catch (error) {
      spinner.fail('Failed');
      console.error(chalk.red(`Error: ${(error as Error).message}`));
      process.exit(1);
    }
  });

// Bus factor command
program
  .command('busfactor')
  .description('Analyze bus factor and knowledge distribution')
  .argument('[path]', 'Path to the repository', '.')
  .option('-f, --file <path>', 'Save HTML report to file')
  .action(async (path: string, options: { file?: string }) => {
    showBanner();
    const repoPath = resolve(path);

    const isRepo = await isGitRepository(repoPath);
    if (!isRepo) {
      console.error(chalk.red(`Error: Not a git repository: ${repoPath}`));
      process.exit(1);
    }

    const spinner = ora('Analyzing bus factor...').start();

    try {
      const report = await analyzeRepository({ repoPath });
      spinner.stop();

      const { busFactor } = report;

      await handleOutput(busFactor, options, () => {
        let output = '';
        output += '\n';
        output += chalk.bold.cyan(`  üöå Bus Factor Analysis`) + '\n';
        output += chalk.gray(`  ${'‚îÄ'.repeat(50)}`) + '\n';

        const bfColor = busFactor.overall <= 1 ? chalk.red :
                        busFactor.overall <= 2 ? chalk.yellow : chalk.green;
        const bfEmoji = busFactor.overall <= 1 ? 'üö®' :
                        busFactor.overall <= 2 ? '‚ö†Ô∏è' : '‚úÖ';

        output += `\n  Overall Bus Factor: ${bfColor.bold(busFactor.overall.toString())} ${bfEmoji}\n`;

        if (busFactor.criticalAreas.length > 0) {
          const highRisk = busFactor.criticalAreas.filter(a => a.risk === 'high');
          const mediumRisk = busFactor.criticalAreas.filter(a => a.risk === 'medium');

          output += `\n  ${chalk.red('High risk areas:')} ${highRisk.length}\n`;
          output += `  ${chalk.yellow('Medium risk areas:')} ${mediumRisk.length}\n`;

          if (highRisk.length > 0) {
            output += chalk.gray(`\n  ${'‚îÄ'.repeat(50)}`) + '\n';
            output += chalk.bold.red('\n  Critical Files (single point of failure):') + '\n';

            highRisk.slice(0, 10).forEach((area) => {
              const areaPath = area.path.length > 40 ? '...' + area.path.slice(-37) : area.path;
              const owner = area.soleContributor?.name || 'Unknown';
              output += `    ${chalk.red('‚óè')} ${areaPath}\n`;
              output += `      ${chalk.gray('Owner:')} ${owner}\n`;
            });
          }
        } else {
          output += chalk.green('\n  ‚úÖ No critical risk areas detected') + '\n';
        }

        output += '\n';
        return output;
      }, renderBusFactorHtml);
    } catch (error) {
      spinner.fail('Failed');
      console.error(chalk.red(`Error: ${(error as Error).message}`));
      process.exit(1);
    }
  });

// Velocity command
program
  .command('velocity')
  .description('Analyze development velocity and trends')
  .argument('[path]', 'Path to the repository', '.')
  .option('-f, --file <path>', 'Save HTML report to file')
  .action(async (path: string, options: { file?: string }) => {
    showBanner();
    const repoPath = resolve(path);

    const isRepo = await isGitRepository(repoPath);
    if (!isRepo) {
      console.error(chalk.red(`Error: Not a git repository: ${repoPath}`));
      process.exit(1);
    }

    const spinner = ora('Analyzing velocity...').start();

    try {
      const report = await analyzeRepository({ repoPath });
      spinner.stop();

      const velocity = report.velocity;
      if (!velocity) {
        console.log(chalk.yellow('No velocity data available'));
        return;
      }

      await handleOutput(velocity, options, () => {
        let output = '';
        output += '\n';
        output += chalk.bold.cyan(`  üöÄ Development Velocity`) + '\n';
        output += chalk.gray(`  ${'‚îÄ'.repeat(50)}`) + '\n';

        const trendEmoji = velocity.trend === 'accelerating' ? 'üìà' :
                           velocity.trend === 'decelerating' ? 'üìâ' : '‚û°Ô∏è';
        const trendColor = velocity.trend === 'accelerating' ? chalk.green :
                           velocity.trend === 'decelerating' ? chalk.red : chalk.yellow;

        output += `\n  ${chalk.bold('Commits per day:')}    ${velocity.commitsPerDay.toFixed(2)}\n`;
        output += `  ${chalk.bold('Commits per week:')}   ${velocity.commitsPerWeek.toFixed(2)}\n`;
        output += `  ${chalk.bold('Commits per month:')}  ${velocity.commitsPerMonth.toFixed(2)}\n`;
        output += `\n  ${chalk.bold('Trend:')} ${trendColor(velocity.trend)} ${trendEmoji} (${velocity.trendPercentage > 0 ? '+' : ''}${velocity.trendPercentage.toFixed(1)}%)\n`;
        output += `  ${chalk.bold('Consistency score:')} ${velocity.consistencyScore.toFixed(0)}%\n`;
        output += `  ${chalk.bold('Avg time between commits:')} ${velocity.averageTimeBetweenCommits.toFixed(1)} hours\n`;

        if (velocity.mtblc && velocity.mtblc > 0) {
          output += `  ${chalk.bold('Large commit frequency:')} ${velocity.largeCommitFrequency}\n`;
        }

        if (velocity.busiestWeek) {
          output += `\n  ${chalk.bold('Busiest week:')}  ${velocity.busiestWeek.week} (${velocity.busiestWeek.commits} commits)\n`;
        }
        if (velocity.slowestWeek) {
          output += `  ${chalk.bold('Slowest week:')}  ${velocity.slowestWeek.week} (${velocity.slowestWeek.commits} commits)\n`;
        }

        if (velocity.releaseRhythm && velocity.releaseRhythm.releases.length > 0) {
          output += chalk.bold(`\n  üì¶ Release Rhythm:`) + '\n';
          output += `    Frequency: ${chalk.cyan(velocity.releaseRhythm.releaseFrequency)}\n`;
          output += `    Avg days between releases: ${velocity.releaseRhythm.averageDaysBetweenReleases}\n`;
          if (velocity.releaseRhythm.lastRelease) {
            output += `    Days since last release: ${velocity.releaseRhythm.daysSinceLastRelease}\n`;
          }
        }

        if (velocity.velocityByDayOfWeek) {
          const days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
          const max = Math.max(...velocity.velocityByDayOfWeek);
          output += chalk.bold(`\n  üìÖ Commits by Day of Week:`) + '\n';
          velocity.velocityByDayOfWeek.forEach((count, i) => {
            const bar = max > 0 ? '‚ñà'.repeat(Math.round((count / max) * 20)) : '';
            output += `    ${days[i].padEnd(4)} ${chalk.cyan(bar.padEnd(20))} ${count}\n`;
          });
        }

        if (velocity.codebaseEvolution && velocity.codebaseEvolution.monthly.length > 0) {
          const evolution = velocity.codebaseEvolution;
          output += chalk.bold(`\n  üìà Codebase Evolution:`) + '\n';
          output += `    Total LOC growth: ${evolution.totalGrowth > 0 ? chalk.green('+' + evolution.totalGrowth.toLocaleString()) : chalk.red(evolution.totalGrowth.toLocaleString())}\n`;
          output += `    Avg monthly growth: ${evolution.averageMonthlyGrowth > 0 ? '+' : ''}${evolution.averageMonthlyGrowth.toLocaleString()} lines\n`;
          output += `    File count trend: ${evolution.fileCountTrend}\n`;

          if (evolution.largestExpansion.month !== 'N/A') {
            output += `    Largest expansion: ${chalk.cyan(evolution.largestExpansion.month)} (+${evolution.largestExpansion.additions.toLocaleString()} lines)\n`;
          }
          if (evolution.largestRefactor.month !== 'N/A') {
            output += `    Largest refactor: ${chalk.yellow(evolution.largestRefactor.month)} (-${evolution.largestRefactor.deletions.toLocaleString()} lines)\n`;
          }

          output += chalk.bold(`\n    Recent monthly evolution:`) + '\n';
          const recentMonths = evolution.monthly.slice(-6);
          for (const month of recentMonths) {
            const change = month.netChange >= 0 ? chalk.green(`+${month.netChange}`) : chalk.red(month.netChange.toString());
            output += `      ${month.month}: ${change} (${chalk.gray(`+${month.filesAdded}/-${month.filesDeleted} files`)})\n`;
          }
        }

        output += '\n';
        return output;
      }, renderVelocityHtml);
    } catch (error) {
      spinner.fail('Failed');
      console.error(chalk.red(`Error: ${(error as Error).message}`));
      process.exit(1);
    }
  });

// Complexity command
program
  .command('complexity')
  .description('Analyze code complexity and identify problematic files')
  .argument('[path]', 'Path to the repository', '.')
  .option('-n, --top <n>', 'Show top N items', parseInt, 10)
  .option('-f, --file <path>', 'Save HTML report to file')
  .action(async (path: string, options: { top: number; file?: string }) => {
    showBanner();
    const repoPath = resolve(path);

    const isRepo = await isGitRepository(repoPath);
    if (!isRepo) {
      console.error(chalk.red(`Error: Not a git repository: ${repoPath}`));
      process.exit(1);
    }

    const spinner = ora('Analyzing complexity...').start();

    try {
      const report = await analyzeRepository({ repoPath });
      spinner.stop();

      const complexity = report.complexity;
      if (!complexity) {
        console.log(chalk.yellow('No complexity data available'));
        return;
      }

      // CLI output
      console.log('');
      console.log(chalk.bold.magenta(`  üß© Code Complexity Analysis`));
      console.log(chalk.gray(`  ${'‚îÄ'.repeat(60)}`));

      console.log(`\n  ${chalk.bold('Average file growth:')} ${complexity.averageFileGrowth.toFixed(1)} lines`);
      console.log(`  ${chalk.bold('High churn files:')} ${complexity.filesWithHighChurn}`);

      if (complexity.technicalDebtScore !== undefined) {
        const debtColor = complexity.technicalDebtScore < 30 ? chalk.green :
                          complexity.technicalDebtScore < 60 ? chalk.yellow : chalk.red;
        console.log(`  ${chalk.bold('Technical Debt Score:')} ${debtColor(complexity.technicalDebtScore.toString())}/100`);

        if (complexity.debtTrend) {
          const trendEmoji = complexity.debtTrend === 'increasing' ? 'üìà' :
                            complexity.debtTrend === 'decreasing' ? 'üìâ' : '‚û°Ô∏è';
          console.log(`  ${chalk.bold('Debt Trend:')} ${complexity.debtTrend} ${trendEmoji}`);
        }
      }

      if (complexity.debtIndicators && complexity.debtIndicators.length > 0) {
        console.log(chalk.bold(`\n  üí≥ Debt Indicators:`));
        for (const indicator of complexity.debtIndicators) {
          const statusEmoji = indicator.status === 'good' ? '‚úÖ' :
                              indicator.status === 'warning' ? '‚ö†Ô∏è' : '‚ùå';
          const statusColor = indicator.status === 'good' ? chalk.green :
                              indicator.status === 'warning' ? chalk.yellow : chalk.red;
          console.log(`    ${statusEmoji} ${indicator.name.padEnd(18)} ${statusColor(indicator.value.toString().padStart(5))}`);
          console.log(`       ${chalk.gray(indicator.description)}`);
        }
      }

      if (complexity.debtByModule && complexity.debtByModule.length > 0) {
        console.log(chalk.bold(`\n  üìÅ Debt by Module:`));
        complexity.debtByModule.slice(0, 5).forEach(mod => {
          const scoreColor = mod.debtScore < 30 ? chalk.green :
                            mod.debtScore < 60 ? chalk.yellow : chalk.red;
          console.log(`    ${mod.path.padEnd(25)} ${scoreColor(mod.debtScore.toString() + '%')} (${mod.filesWithDebt}/${mod.totalFiles} files)`);
          if (mod.topIssues.length > 0) {
            console.log(`      ${chalk.gray(mod.topIssues.join(', '))}`);
          }
        });
      }

      if (complexity.godFiles.length > 0) {
        console.log(chalk.bold.red(`\n  ‚ö†Ô∏è  God Files (too many changes):`));
        complexity.godFiles.slice(0, options.top).forEach(file => {
          const filePath = file.path.length > 45 ? '...' + file.path.slice(-42) : file.path.padEnd(45);
          console.log(`    ${chalk.red('‚óè')} ${filePath} ${chalk.gray(file.reason)}`);
        });
      }

      if (complexity.growingFiles.length > 0) {
        console.log(chalk.bold.yellow(`\n  üìà Rapidly Growing Files:`));
        complexity.growingFiles.slice(0, options.top).forEach(file => {
          const filePath = file.path.length > 45 ? '...' + file.path.slice(-42) : file.path.padEnd(45);
          console.log(`    ${chalk.yellow('‚óè')} ${filePath} +${file.netGrowth} lines (${file.trend})`);
        });
      }

      if (complexity.refactoringCandidates.length > 0) {
        console.log(chalk.bold.blue(`\n  üîß Refactoring Candidates:`));
        complexity.refactoringCandidates.slice(0, options.top).forEach(file => {
          const filePath = file.path.length > 45 ? '...' + file.path.slice(-42) : file.path.padEnd(45);
          console.log(`    ${chalk.blue('‚óè')} ${filePath}`);
          console.log(`      ${chalk.gray(file.suggestion)}`);
        });
      }

      if (complexity.criticalHotspots && complexity.criticalHotspots.length > 0) {
        console.log(chalk.bold.red(`\n  üî• Critical Hotspots (High Churn + High Changes):`));
        complexity.criticalHotspots.slice(0, options.top).forEach(hotspot => {
          const filePath = hotspot.path.length > 40 ? '...' + hotspot.path.slice(-37) : hotspot.path.padEnd(40);
          const riskColor = hotspot.riskLevel === 'critical' ? chalk.red :
                           hotspot.riskLevel === 'high' ? chalk.yellow : chalk.gray;
          console.log(`    ${riskColor('‚óè')} ${filePath} Risk: ${riskColor(hotspot.riskScore.toString())}%`);
          console.log(`      ${chalk.gray(`${hotspot.commitCount} commits, ${hotspot.totalChanges.toLocaleString()} LOC, ${hotspot.authorCount} authors`)}`);
          console.log(`      ${chalk.gray(hotspot.riskFactors.join(' | '))}`);
        });
      }

      console.log('');

      // HTML output if requested
      if (options.file) {
        const htmlContent = renderComplexityHtml(complexity);
        await writeFile(options.file, htmlContent);
        console.log(chalk.green(`\nüìÑ HTML saved to: ${options.file}`));
      }
    } catch (error) {
      spinner.fail('Failed');
      console.error(chalk.red(`Error: ${(error as Error).message}`));
      process.exit(1);
    }
  });

// Work patterns command
program
  .command('workpatterns')
  .description('Analyze work patterns and team habits')
  .argument('[path]', 'Path to the repository', '.')
  .option('-f, --file <path>', 'Save HTML report to file')
  .action(async (path: string, options: { file?: string }) => {
    showBanner();
    const repoPath = resolve(path);

    const isRepo = await isGitRepository(repoPath);
    if (!isRepo) {
      console.error(chalk.red(`Error: Not a git repository: ${repoPath}`));
      process.exit(1);
    }

    const spinner = ora('Analyzing work patterns...').start();

    try {
      const report = await analyzeRepository({ repoPath });
      spinner.stop();

      const patterns = report.workPatterns;
      if (!patterns) {
        console.log(chalk.yellow('No work patterns data available'));
        return;
      }

      const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
      const peakHourFormatted = `${patterns.peakHour.toString().padStart(2, '0')}:00`;

      console.log('');
      console.log(chalk.bold.cyan(`  ‚è∞ Work Patterns Analysis`));
      console.log(chalk.gray(`  ${'‚îÄ'.repeat(50)}`));

      console.log(`\n  ${chalk.bold('Peak hour:')}           ${peakHourFormatted}`);
      console.log(`  ${chalk.bold('Peak day:')}            ${days[patterns.peakDay]}`);
      console.log(`  ${chalk.bold('Night owl %:')}         ${patterns.nightOwlPercentage.toFixed(1)}%`);
      console.log(`  ${chalk.bold('Weekend commits %:')}   ${patterns.weekendPercentage.toFixed(1)}%`);
      console.log(`  ${chalk.bold('Work-life balance:')}   ${patterns.workLifeBalance.toFixed(0)}/100`);

      console.log(chalk.bold(`\n  Hourly Distribution:`));
      const hourRanges = [
        { label: 'Night   00-06', start: 0, end: 6, color: chalk.blue },
        { label: 'Morning 06-12', start: 6, end: 12, color: chalk.yellow },
        { label: 'Afternoon 12-18', start: 12, end: 18, color: chalk.green },
        { label: 'Evening 18-24', start: 18, end: 24, color: chalk.magenta },
      ];

      const totalCommits = patterns.hourlyDistribution.reduce((a, b) => a + b, 0);
      const maxRange = Math.max(...hourRanges.map(r =>
        patterns.hourlyDistribution.slice(r.start, r.end).reduce((a, b) => a + b, 0)
      ));

      for (const range of hourRanges) {
        const count = patterns.hourlyDistribution.slice(range.start, range.end).reduce((a, b) => a + b, 0);
        const pct = totalCommits > 0 ? (count / totalCommits * 100) : 0;
        const barWidth = maxRange > 0 ? Math.round((count / maxRange) * 25) : 0;
        const bar = '‚ñà'.repeat(barWidth);
        console.log(`    ${range.label.padEnd(16)} ${range.color(bar.padEnd(25))} ${count.toString().padStart(4)} (${pct.toFixed(0)}%)`);
      }

      if (patterns.crunchPeriods.length > 0) {
        console.log(chalk.bold.red(`\n  üî• Crunch Periods Detected:`));
        patterns.crunchPeriods.slice(0, 5).forEach(period => {
          const severityColor = period.severity === 'severe' ? chalk.red :
                               period.severity === 'moderate' ? chalk.yellow : chalk.gray;
          console.log(`    ${severityColor('‚óè')} ${period.startDate} to ${period.endDate} (${period.severity})`);
        });
      }

      console.log('');

      if (options.file) {
        const htmlContent = renderWorkPatternsHtml(patterns);
        await writeFile(options.file, htmlContent);
        console.log(chalk.green(`\nüìÑ HTML saved to: ${options.file}`));
      }
    } catch (error) {
      spinner.fail('Failed');
      console.error(chalk.red(`Error: ${(error as Error).message}`));
      process.exit(1);
    }
  });

// Commits quality command
program
  .command('commits')
  .description('Analyze commit quality and patterns')
  .argument('[path]', 'Path to the repository', '.')
  .option('-f, --file <path>', 'Save HTML report to file')
  .action(async (path: string, options: { file?: string }) => {
    showBanner();
    const repoPath = resolve(path);

    const isRepo = await isGitRepository(repoPath);
    if (!isRepo) {
      console.error(chalk.red(`Error: Not a git repository: ${repoPath}`));
      process.exit(1);
    }

    const spinner = ora('Analyzing commit quality...').start();

    try {
      const report = await analyzeRepository({ repoPath });
      spinner.stop();

      const quality = report.commitQuality;
      if (!quality) {
        console.log(chalk.yellow('No commit quality data available'));
        return;
      }

      console.log('');
      console.log(chalk.bold.cyan(`  üìù Commit Quality Analysis`));
      console.log(chalk.gray(`  ${'‚îÄ'.repeat(50)}`));

      const qualityColor = quality.qualityScore >= 80 ? chalk.green :
                          quality.qualityScore >= 60 ? chalk.yellow : chalk.red;

      console.log(`\n  ${chalk.bold('Quality Score:')}        ${qualityColor(quality.qualityScore.toFixed(0) + '/100')}`);
      console.log(`  ${chalk.bold('Atomic Score:')}         ${quality.atomicCommitScore.toFixed(0)}/100`);
      console.log(`  ${chalk.bold('Avg message length:')}   ${quality.averageMessageLength.toFixed(0)} chars`);
      console.log(`  ${chalk.bold('Conventional commits:')} ${quality.conventionalPercentage.toFixed(1)}%`);
      console.log(`  ${chalk.bold('Fix/bugfix commits:')}   ${quality.fixPercentage.toFixed(1)}%`);

      // Commit types breakdown
      const types = Object.entries(quality.commitTypes).sort((a, b) => b[1] - a[1]);
      if (types.length > 0) {
        console.log(chalk.bold(`\n  Commit Types:`));
        types.slice(0, 8).forEach(([type, count]) => {
          const bar = '‚ñà'.repeat(Math.min(20, Math.round((count / types[0][1]) * 20)));
          console.log(`    ${type.padEnd(12)} ${chalk.cyan(bar)} ${count}`);
        });
      }

      if (quality.wipCommits.length > 0) {
        console.log(chalk.bold.yellow(`\n  ‚ö†Ô∏è  WIP/Incomplete Commits: ${quality.wipCommits.length}`));
        quality.wipCommits.slice(0, 5).forEach(commit => {
          console.log(`    ${chalk.gray(commit.hash.slice(0, 7))} ${commit.message.slice(0, 50)}`);
        });
      }

      if (quality.largeCommits.length > 0) {
        console.log(chalk.bold.yellow(`\n  üì¶ Large Commits (${quality.largeCommits.length} total):`));
        quality.largeCommits.slice(0, 5).forEach(commit => {
          console.log(`    ${chalk.gray(commit.hash.slice(0, 7))} ${commit.filesChanged} files changed`);
        });
      }

      // Author breakdown by type
      if (quality.authorBreakdown && quality.authorBreakdown.length > 0) {
        console.log(chalk.bold(`\n  üë• Author Contribution Breakdown:`));
        quality.authorBreakdown.slice(0, 5).forEach(author => {
          console.log(`    ${author.author.padEnd(20)} ${chalk.cyan(author.totalCommits + ' commits')} (${chalk.yellow(author.primaryType)})`);
          const typeStr = Object.entries(author.types)
            .sort((a, b) => b[1] - a[1])
            .slice(0, 4)
            .map(([t, c]) => `${t}:${c}`)
            .join(' ');
          console.log(`      ${chalk.gray(typeStr)}`);
        });
      }

      // Type evolution (last 6 months)
      if (quality.typeEvolution && quality.typeEvolution.length > 0) {
        console.log(chalk.bold(`\n  üìà Commit Type Evolution (recent months):`));
        quality.typeEvolution.slice(-6).forEach(entry => {
          const top3 = Object.entries(entry.types)
            .sort((a, b) => b[1] - a[1])
            .slice(0, 3)
            .map(([t, c]) => `${t}:${c}`)
            .join(' ');
          console.log(`    ${entry.month} ${chalk.gray('|')} ${entry.totalCommits.toString().padStart(4)} commits ${chalk.gray('|')} ${top3}`);
        });
      }

      console.log('');

      if (options.file) {
        const htmlContent = renderCommitQualityHtml(quality);
        await writeFile(options.file, htmlContent);
        console.log(chalk.green(`\nüìÑ HTML saved to: ${options.file}`));
      }
    } catch (error) {
      spinner.fail('Failed');
      console.error(chalk.red(`Error: ${(error as Error).message}`));
      process.exit(1);
    }
  });

// Collaboration command
program
  .command('collaboration')
  .description('Analyze team collaboration patterns')
  .argument('[path]', 'Path to the repository', '.')
  .option('-n, --top <n>', 'Show top N items', parseInt, 10)
  .option('-f, --file <path>', 'Save HTML report to file')
  .action(async (path: string, options: { top: number; file?: string }) => {
    showBanner();
    const repoPath = resolve(path);

    const isRepo = await isGitRepository(repoPath);
    if (!isRepo) {
      console.error(chalk.red(`Error: Not a git repository: ${repoPath}`));
      process.exit(1);
    }

    const spinner = ora('Analyzing collaboration...').start();

    try {
      const report = await analyzeRepository({ repoPath });
      spinner.stop();

      const collab = report.collaboration;
      if (!collab) {
        console.log(chalk.yellow('No collaboration data available'));
        return;
      }

      console.log('');
      console.log(chalk.bold.cyan(`  ü§ù Collaboration Analysis`));
      console.log(chalk.gray(`  ${'‚îÄ'.repeat(50)}`));

      const scoreColor = collab.collaborationScore >= 70 ? chalk.green :
                        collab.collaborationScore >= 40 ? chalk.yellow : chalk.red;

      console.log(`\n  ${chalk.bold('Collaboration Score:')} ${scoreColor(collab.collaborationScore.toFixed(0) + '/100')}`);

      if (collab.collaborationPairs.length > 0) {
        console.log(chalk.bold(`\n  Top Collaboration Pairs:`));
        collab.collaborationPairs.slice(0, options.top).forEach(pair => {
          console.log(`    ${chalk.green('‚óè')} ${pair.author1} ‚Üî ${pair.author2}`);
          console.log(`      ${chalk.gray(`${pair.sharedFiles} shared files`)}`);
        });
      }

      if (collab.sharedFiles.length > 0) {
        console.log(chalk.bold(`\n  Most Shared Files:`));
        collab.sharedFiles.slice(0, options.top).forEach(file => {
          const path = file.path.length > 40 ? '...' + file.path.slice(-37) : file.path;
          console.log(`    ${path.padEnd(42)} ${chalk.cyan(file.authorCount + ' authors')}`);
        });
      }

      if (collab.loneWolves.length > 0) {
        console.log(chalk.bold.yellow(`\n  üê∫ Lone Wolves (low collaboration):`));
        collab.loneWolves.slice(0, 5).forEach(wolf => {
          console.log(`    ${wolf.name.padEnd(25)} ${chalk.yellow(wolf.soloPercentage.toFixed(1) + '% solo')}`);
        });
      }

      console.log('');

      if (options.file) {
        const htmlContent = renderCollaborationHtml(collab);
        await writeFile(options.file, htmlContent);
        console.log(chalk.green(`\nüìÑ HTML saved to: ${options.file}`));
      }
    } catch (error) {
      spinner.fail('Failed');
      console.error(chalk.red(`Error: ${(error as Error).message}`));
      process.exit(1);
    }
  });

// Coupling command
program
  .command('coupling')
  .description('Analyze file coupling and dependencies')
  .argument('[path]', 'Path to the repository', '.')
  .option('-n, --top <n>', 'Show top N items', parseInt, 10)
  .option('-f, --file <path>', 'Save HTML report to file')
  .action(async (path: string, options: { top: number; file?: string }) => {
    showBanner();
    const repoPath = resolve(path);

    const isRepo = await isGitRepository(repoPath);
    if (!isRepo) {
      console.error(chalk.red(`Error: Not a git repository: ${repoPath}`));
      process.exit(1);
    }

    const spinner = ora('Analyzing coupling...').start();

    try {
      const report = await analyzeRepository({ repoPath });
      spinner.stop();

      const coupling = report.coupling;
      if (!coupling) {
        console.log(chalk.yellow('No coupling data available'));
        return;
      }

      console.log('');
      console.log(chalk.bold.magenta(`  üîó Coupling Analysis`));
      console.log(chalk.gray(`  ${'‚îÄ'.repeat(60)}`));

      console.log(`\n  ${chalk.bold('Coupling Score:')} ${coupling.couplingScore.toFixed(0)}/100`);

      if (coupling.temporalCoupling.length > 0) {
        console.log(chalk.bold(`\n  Temporal Coupling (files changed together):`));
        coupling.temporalCoupling.slice(0, options.top).forEach(pair => {
          const file1 = pair.file1.length > 30 ? '...' + pair.file1.slice(-27) : pair.file1;
          const file2 = pair.file2.length > 30 ? '...' + pair.file2.slice(-27) : pair.file2;
          const strength = Math.min(100, Math.round(pair.couplingStrength)); // Already in %, cap at 100
          const color = strength > 80 ? chalk.red : strength > 50 ? chalk.yellow : chalk.green;
          console.log(`    ${color('‚óè')} ${file1}`);
          console.log(`      ‚Üî ${file2} ${color(`(${strength}%)`)}`);
        });
      }

      if (coupling.highImpactCommits.length > 0) {
        console.log(chalk.bold.yellow(`\n  ‚ö° High Impact Commits:`));
        coupling.highImpactCommits.slice(0, 5).forEach(commit => {
          console.log(`    ${chalk.gray(commit.hash.slice(0, 7))} ${commit.filesChanged} files (impact: ${commit.impactScore.toFixed(0)})`);
        });
      }

      if (coupling.hiddenDependencies.length > 0) {
        console.log(chalk.bold.red(`\n  üïµÔ∏è  Hidden Dependencies:`));
        coupling.hiddenDependencies.slice(0, options.top).forEach(dep => {
          const file1 = dep.file1.length > 35 ? '...' + dep.file1.slice(-32) : dep.file1;
          const file2 = dep.file2.length > 35 ? '...' + dep.file2.slice(-32) : dep.file2;
          console.log(`    ${chalk.red('‚óè')} ${file1} ‚Üî ${file2}`);
          console.log(`      ${chalk.gray(dep.reason)}`);
        });
      }

      console.log('');

      if (options.file) {
        const htmlContent = renderCouplingHtml(coupling);
        await writeFile(options.file, htmlContent);
        console.log(chalk.green(`\nüìÑ HTML saved to: ${options.file}`));
      }
    } catch (error) {
      spinner.fail('Failed');
      console.error(chalk.red(`Error: ${(error as Error).message}`));
      process.exit(1);
    }
  });

// Health command
program
  .command('health')
  .description('Analyze repository health and code freshness')
  .argument('[path]', 'Path to the repository', '.')
  .option('-f, --file <path>', 'Save HTML report to file')
  .action(async (path: string, options: { file?: string }) => {
    showBanner();
    const repoPath = resolve(path);

    const isRepo = await isGitRepository(repoPath);
    if (!isRepo) {
      console.error(chalk.red(`Error: Not a git repository: ${repoPath}`));
      process.exit(1);
    }

    const spinner = ora('Analyzing health...').start();

    try {
      const report = await analyzeRepository({ repoPath });
      spinner.stop();

      const health = report.health;
      if (!health) {
        console.log(chalk.yellow('No health data available'));
        return;
      }

      console.log('');
      console.log(chalk.bold.cyan(`  üè• Repository Health`));
      console.log(chalk.gray(`  ${'‚îÄ'.repeat(50)}`));

      const scoreColor = health.healthScore >= 80 ? chalk.green :
                        health.healthScore >= 60 ? chalk.yellow : chalk.red;
      const scoreEmoji = health.healthScore >= 80 ? 'üíö' :
                        health.healthScore >= 60 ? 'üíõ' : '‚ù§Ô∏è';

      console.log(`\n  ${chalk.bold('Health Score:')} ${scoreColor(health.healthScore.toString())} ${scoreEmoji}`);

      // Health indicators
      console.log(chalk.bold(`\n  Health Indicators:`));
      health.indicators.forEach(indicator => {
        const statusEmoji = indicator.status === 'good' ? '‚úÖ' :
                           indicator.status === 'warning' ? '‚ö†Ô∏è' : '‚ùå';
        const statusColor = indicator.status === 'good' ? chalk.green :
                           indicator.status === 'warning' ? chalk.yellow : chalk.red;
        console.log(`    ${statusEmoji} ${indicator.name.padEnd(20)} ${statusColor(indicator.value.padStart(8))}`);
        console.log(`       ${chalk.gray(indicator.description)}`);
      });

      // Age distribution
      const total = Object.values(health.ageDistribution).reduce((a, b) => a + b, 0);
      if (total > 0) {
        console.log(chalk.bold(`\n  File Age Distribution:`));
        const dist = health.ageDistribution;
        const labels = [
          { name: 'Fresh (<30d)', value: dist.fresh, color: chalk.green },
          { name: 'Recent (30-90d)', value: dist.recent, color: chalk.cyan },
          { name: 'Aging (90-180d)', value: dist.aging, color: chalk.yellow },
          { name: 'Old (180-365d)', value: dist.old, color: chalk.magenta },
          { name: 'Ancient (>365d)', value: dist.ancient, color: chalk.red },
        ];
        labels.forEach(({ name, value, color }) => {
          const pct = ((value / total) * 100).toFixed(1);
          const bar = '‚ñà'.repeat(Math.round((value / total) * 30));
          console.log(`    ${name.padEnd(18)} ${color(bar.padEnd(30))} ${value} (${pct}%)`);
        });
      }

      if (health.zombieFiles.length > 0) {
        // Get total count from indicator
        const zombieIndicator = health.indicators.find(i => i.name === 'Zombie Files');
        const totalZombies = zombieIndicator ? parseInt(zombieIndicator.value) : health.zombieFiles.length;

        console.log(chalk.bold.red(`\n  üßü Zombie Files (single commit, 6+ months old):`));
        health.zombieFiles.slice(0, 5).forEach(file => {
          const path = file.path.length > 45 ? '...' + file.path.slice(-42) : file.path;
          console.log(`    ${chalk.red('‚óè')} ${path} (${file.daysSinceModified} days)`);
        });
        if (totalZombies > 5) {
          console.log(chalk.gray(`    ... and ${totalZombies - 5} more`));
        }
      }

      if (health.abandonedDirs.length > 0) {
        console.log(chalk.bold.yellow(`\n  üìÇ Abandoned Directories:`));
        health.abandonedDirs.slice(0, 5).forEach(dir => {
          console.log(`    ${chalk.yellow('‚óè')} ${dir.path} (${dir.daysSinceActivity} days, ${dir.fileCount} files)`);
        });
      }

      // Test metrics
      if (health.testMetrics) {
        const tm = health.testMetrics;
        console.log(chalk.bold(`\n  üß™ Test Metrics:`));
        console.log(`    Test files: ${chalk.cyan(tm.testFiles.toString())}`);
        console.log(`    Source files: ${tm.sourceFiles}`);
        console.log(`    Test/Code ratio: ${chalk.cyan((tm.testToCodeRatio * 100).toFixed(0) + '%')}`);
        console.log(`    Estimated coverage: ${chalk.cyan(tm.testCoverage)}`);
        console.log(`    Recent test activity: ${tm.recentTestActivity} files`);

        if (Object.keys(tm.testTypes).length > 0) {
          const typeStr = Object.entries(tm.testTypes)
            .filter(([, v]) => v > 0)
            .map(([k, v]) => `${k}: ${v}`)
            .join(', ');
          console.log(`    Test types: ${chalk.gray(typeStr)}`);
        }

        if (tm.modulesWithoutTests.length > 0) {
          console.log(chalk.bold.yellow(`\n  ‚ö†Ô∏è  Modules Without Tests:`));
          tm.modulesWithoutTests.slice(0, 5).forEach(mod => {
            console.log(`    ${chalk.yellow('‚óè')} ${mod.path} (${mod.sourceFiles} source files)`);
          });
        }
      }

      console.log('');

      if (options.file) {
        const htmlContent = renderHealthHtml(health);
        await writeFile(options.file, htmlContent);
        console.log(chalk.green(`\nüìÑ HTML saved to: ${options.file}`));
      }
    } catch (error) {
      spinner.fail('Failed');
      console.error(chalk.red(`Error: ${(error as Error).message}`));
      process.exit(1);
    }
  });

// Branches command
program
  .command('branches')
  .description('Analyze branch health and patterns')
  .argument('[path]', 'Path to the repository', '.')
  .option('-f, --file <path>', 'Save HTML report to file')
  .action(async (path: string, options: { file?: string }) => {
    showBanner();
    const repoPath = resolve(path);

    const isRepo = await isGitRepository(repoPath);
    if (!isRepo) {
      console.error(chalk.red(`Error: Not a git repository: ${repoPath}`));
      process.exit(1);
    }

    const spinner = ora('Analyzing branches...').start();

    try {
      const report = await analyzeRepository({ repoPath });
      spinner.stop();

      const branchStats = report.branchAnalysis;
      if (!branchStats) {
        console.log(chalk.yellow('No branch data available'));
        return;
      }

      console.log('');
      console.log(chalk.bold.cyan(`  üåø Branch Analysis`));
      console.log(chalk.gray(`  ${'‚îÄ'.repeat(50)}`));

      const scoreColor = branchStats.branchHealthScore >= 80 ? chalk.green :
                        branchStats.branchHealthScore >= 60 ? chalk.yellow : chalk.red;

      console.log(`\n  ${chalk.bold('Branch Health Score:')} ${scoreColor(branchStats.branchHealthScore.toString())}/100`);
      console.log(`  ${chalk.bold('Total branches:')}       ${branchStats.totalBranches}`);
      console.log(`  ${chalk.bold('Average branch age:')}   ${branchStats.averageBranchAge} days`);

      if (branchStats.oldestBranch) {
        console.log(`  ${chalk.bold('Oldest branch:')}        ${branchStats.oldestBranch.name} (${branchStats.oldestBranch.age} days)`);
      }
      if (branchStats.newestBranch) {
        console.log(`  ${chalk.bold('Newest branch:')}        ${branchStats.newestBranch.name} (${branchStats.newestBranch.age} days)`);
      }

      // Naming patterns
      if (branchStats.namingPatterns.length > 0) {
        console.log(chalk.bold(`\n  Naming Patterns:`));
        branchStats.namingPatterns.forEach(pattern => {
          console.log(`    ${pattern.pattern.padEnd(15)} ${chalk.cyan(pattern.count.toString())} - ${chalk.gray(pattern.description)}`);
        });
      }

      // Stale branches
      if (branchStats.staleBranches.length > 0) {
        console.log(chalk.bold.yellow(`\n  ‚ö†Ô∏è  Stale Branches (${branchStats.staleBranches.length} total):`));
        branchStats.staleBranches.slice(0, 10).forEach(branch => {
          const name = branch.name.length > 35 ? '...' + branch.name.slice(-32) : branch.name;
          console.log(`    ${chalk.yellow('‚óè')} ${name.padEnd(38)} ${chalk.gray(branch.daysSinceCommit + ' days')}`);
          console.log(`      ${chalk.gray(branch.recommendation)}`);
        });
      }

      // Orphan branches
      if (branchStats.orphanBranches.length > 0) {
        console.log(chalk.bold.red(`\n  üëª Orphan Branches (${branchStats.orphanBranches.length} total):`));
        branchStats.orphanBranches.slice(0, 5).forEach(branch => {
          const name = branch.name.length > 35 ? '...' + branch.name.slice(-32) : branch.name;
          console.log(`    ${chalk.red('‚óè')} ${name}`);
          console.log(`      ${chalk.gray(branch.reason)}`);
        });
      }

      // Branch lifecycle metrics
      if (branchStats.branchLifecycle) {
        const lifecycle = branchStats.branchLifecycle;
        console.log(chalk.bold(`\n  üìä Branch Lifecycle:`));
        console.log(`    ${chalk.bold('Workflow type:')}        ${chalk.cyan(lifecycle.workflowType)}`);
        console.log(`    ${chalk.bold('Active branches:')}      ${chalk.green(lifecycle.activeCount.toString())} (${lifecycle.activePercentage}%)`);
        console.log(`    ${chalk.bold('Inactive branches:')}    ${chalk.yellow(lifecycle.inactiveCount.toString())}`);
        console.log(`    ${chalk.bold('Stale branches:')}       ${chalk.red(lifecycle.staleCount.toString())}`);
        console.log(`    ${chalk.bold('Merged branches:')}      ${lifecycle.mergedBranches} (${lifecycle.mergeRate}% merge rate)`);
        console.log(`    ${chalk.bold('Avg branch lifespan:')}  ${lifecycle.estimatedAvgLifespan} days`);

        if (lifecycle.shortLivedBranches > 0 || lifecycle.longLivedBranches > 0) {
          console.log(`    ${chalk.bold('Short-lived (<7d):')}    ${lifecycle.shortLivedBranches}`);
          console.log(`    ${chalk.bold('Long-lived (>30d):')}    ${lifecycle.longLivedBranches}`);
        }

        console.log(chalk.bold(`\n  üìÖ Recent Activity:`));
        console.log(`    Branches created (last 30 days): ${lifecycle.branchesCreatedLast30Days}`);
        console.log(`    Branches created (last 90 days): ${lifecycle.branchesCreatedLast90Days}`);
      }

      console.log('');

      if (options.file) {
        const htmlContent = renderBranchesHtml(branchStats);
        await writeFile(options.file, htmlContent);
        console.log(chalk.green(`\nüìÑ HTML saved to: ${options.file}`));
      }
    } catch (error) {
      spinner.fail('Failed');
      console.error(chalk.red(`Error: ${(error as Error).message}`));
      process.exit(1);
    }
  });

// Burnout command
program
  .command('burnout')
  .description('Analyze work patterns to detect burnout risk')
  .argument('[path]', 'Path to the repository', '.')
  .option('-f, --file <path>', 'Save HTML report to file')
  .action(async (path: string, options: { file?: string }) => {
    showBanner();
    const repoPath = resolve(path);

    const isRepo = await isGitRepository(repoPath);
    if (!isRepo) {
      console.error(chalk.red(`Error: Not a git repository: ${repoPath}`));
      process.exit(1);
    }

    const spinner = ora('Analyzing burnout risk...').start();

    try {
      const parser = createGitParser(repoPath);
      const commits = await parser.getCommits();
      const analyzer = createBurnoutAnalyzer();
      const burnout = await analyzer.analyze(commits, { repoPath });
      spinner.stop();

      await handleOutput(burnout, options, () => {
        let output = '';
        output += '\n';
        output += chalk.bold.red(`  üî• Burnout Risk Analysis`) + '\n';
        output += chalk.gray(`  ${'‚îÄ'.repeat(50)}`) + '\n';

        // Team risk
        const riskColor = burnout.teamRiskLevel === 'critical' ? chalk.red :
                         burnout.teamRiskLevel === 'high' ? chalk.yellow :
                         burnout.teamRiskLevel === 'medium' ? chalk.cyan : chalk.green;
        const riskEmoji = burnout.teamRiskLevel === 'critical' ? 'üö®' :
                         burnout.teamRiskLevel === 'high' ? '‚ö†Ô∏è' :
                         burnout.teamRiskLevel === 'medium' ? 'üìä' : '‚úÖ';

        output += `\n  ${chalk.bold('Team Burnout Risk:')} ${riskColor(burnout.teamRiskLevel.toUpperCase())} ${riskEmoji}\n`;
        output += `  ${chalk.bold('Risk Score:')}         ${riskColor(burnout.teamRiskScore.toString())}/100\n`;

        // Team patterns
        const tp = burnout.teamPatterns;
        output += chalk.bold(`\n  Team Patterns:`) + '\n';
        output += `    Night commits:     ${tp.avgNightCommitPercentage.toFixed(1)}%\n`;
        output += `    Weekend commits:   ${tp.avgWeekendCommitPercentage.toFixed(1)}%\n`;
        output += `    Work-life balance: ${tp.teamWorkLifeBalance.toFixed(0)}/100\n`;
        output += `    Developers at risk: ${chalk.red(tp.developersAtRisk.toString())} | Healthy: ${chalk.green(tp.developersHealthy.toString())}\n`;

        // Individual risks
        if (burnout.developerRisks.length > 0) {
          output += chalk.bold(`\n  Individual Risk Assessment:`) + '\n';
          burnout.developerRisks.slice(0, 10).forEach(dev => {
            const color = dev.riskLevel === 'critical' ? chalk.red :
                         dev.riskLevel === 'high' ? chalk.yellow :
                         dev.riskLevel === 'medium' ? chalk.cyan : chalk.green;
            const emoji = dev.riskLevel === 'critical' ? 'üî¥' :
                         dev.riskLevel === 'high' ? 'üü°' :
                         dev.riskLevel === 'medium' ? 'üü†' : 'üü¢';

            const name = dev.name.length > 20 ? dev.name.slice(0, 17) + '...' : dev.name;
            output += `    ${emoji} ${name.padEnd(20)} ${color(dev.riskLevel.padEnd(10))} Score: ${dev.riskScore}\n`;

            if (dev.signals.length > 0) {
              const topSignal = dev.signals[0];
              output += `       ${chalk.gray('‚îî‚îÄ')} ${topSignal.description}\n`;
            }
          });
        }

        // Crunch periods
        if (tp.crunchPeriodsDetected.length > 0) {
          output += chalk.bold.red(`\n  üî• Crunch Periods Detected:`) + '\n';
          tp.crunchPeriodsDetected.slice(0, 3).forEach(crunch => {
            const intensity = crunch.intensity === 'extreme' ? chalk.red :
                             crunch.intensity === 'high' ? chalk.yellow : chalk.cyan;
            output += `    ${intensity('‚óè')} ${crunch.startDate.toISOString().split('T')[0]} to ${crunch.endDate.toISOString().split('T')[0]}\n`;
            output += `      ${crunch.durationDays} days, ${crunch.developersInvolved.length} devs, ${intensity(crunch.intensity)} intensity\n`;
          });
        }

        // Recommendations
        if (burnout.recommendations.length > 0) {
          output += chalk.bold(`\n  üìã Recommendations:`) + '\n';
          burnout.recommendations.slice(0, 5).forEach(rec => {
            const priority = rec.priority === 'critical' ? chalk.red('CRITICAL') :
                            rec.priority === 'high' ? chalk.yellow('HIGH') :
                            rec.priority === 'medium' ? chalk.cyan('MEDIUM') : chalk.gray('LOW');
            output += `    [${priority}] ${rec.target}\n`;
            output += `      ${chalk.gray(rec.recommendation)}\n`;
          });
        }

        output += '\n';
        return output;
      }, renderBurnoutHtml);
    } catch (error) {
      spinner.fail('Failed');
      console.error(chalk.red(`Error: ${(error as Error).message}`));
      process.exit(1);
    }
  });

// Leaderboard command
program
  .command('leaderboard')
  .description('Show gamified leaderboards and achievements')
  .argument('[path]', 'Path to the repository', '.')
  .option('-t, --top <n>', 'Show top N entries', '5')
  .option('-f, --file <path>', 'Save HTML report to file')
  .action(async (path: string, options: { top: string; file?: string }) => {
    showBanner();
    const repoPath = resolve(path);
    const topN = parseInt(options.top, 10);

    const isRepo = await isGitRepository(repoPath);
    if (!isRepo) {
      console.error(chalk.red(`Error: Not a git repository: ${repoPath}`));
      process.exit(1);
    }

    const spinner = ora('Generating leaderboards...').start();

    try {
      const parser = createGitParser(repoPath);
      const commits = await parser.getCommits();
      const analyzer = createLeaderboardAnalyzer();
      const stats = await analyzer.analyze(commits, { repoPath });
      spinner.stop();

      await handleOutput(stats, options, () => {
        let output = '';
        output += '\n';
        output += chalk.bold.yellow(`  üèÜ GITSTATS LEADERBOARDS üèÜ`) + '\n';
        output += chalk.gray(`  ${'‚îÄ'.repeat(50)}`) + '\n';

        // Show selected leaderboards
        const selectedBoards = ['Most Commits', 'Bug Hunters', 'Consistency Kings', 'Refactor Masters'];

        for (const boardName of selectedBoards) {
          const board = stats.leaderboards.find(b => b.name === boardName);
          if (!board || board.entries.length === 0) continue;

          output += `\n  ${board.emoji} ${chalk.bold(board.name)}\n`;
          output += chalk.gray(`     ${board.description}`) + '\n';

          board.entries.slice(0, topN).forEach(entry => {
            const badge = entry.badge || '  ';
            const name = entry.name.length > 15 ? entry.name.slice(0, 12) + '...' : entry.name;
            output += `    ${badge} ${name.padEnd(15)} ${chalk.cyan(entry.formattedValue)}\n`;
          });
        }

        // Fun stats
        if (stats.funStats.length > 0) {
          output += chalk.bold(`\n  üéâ Fun Stats:`) + '\n';
          stats.funStats.slice(0, 5).forEach(stat => {
            output += `    ${stat.emoji} ${stat.name}: ${chalk.cyan(stat.winner)} - ${stat.value}\n`;
          });
        }

        // Top achievements
        if (stats.achievements.length > 0) {
          output += chalk.bold(`\n  üéñÔ∏è  Top Achievers:`) + '\n';
          stats.achievements.slice(0, 3).forEach(dev => {
            const badges = dev.achievements.slice(0, 5).map(a => a.emoji).join(' ');
            output += `    ${dev.name} - ${chalk.yellow(dev.level)} (${dev.totalPoints} pts)\n`;
            output += `       ${badges}\n`;
          });
        }

        // Records
        if (stats.records.length > 0) {
          output += chalk.bold(`\n  üìú Repository Records:`) + '\n';
          stats.records.forEach(record => {
            output += `    ${record.emoji} ${record.name}: ${chalk.cyan(record.holder)}\n`;
          });
        }

        output += '\n';
        return output;
      }, renderLeaderboardHtml);
    } catch (error) {
      spinner.fail('Failed');
      console.error(chalk.red(`Error: ${(error as Error).message}`));
      process.exit(1);
    }
  });

// Dead code command
program
  .command('deadcode')
  .description('Detect potentially dead or unused code')
  .argument('[path]', 'Path to the repository', '.')
  .option('-f, --file <path>', 'Save HTML report to file')
  .action(async (path: string, options: { file?: string }) => {
    showBanner();
    const repoPath = resolve(path);

    const isRepo = await isGitRepository(repoPath);
    if (!isRepo) {
      console.error(chalk.red(`Error: Not a git repository: ${repoPath}`));
      process.exit(1);
    }

    const spinner = ora('Detecting dead code...').start();

    try {
      const parser = createGitParser(repoPath);
      const commits = await parser.getCommits();
      const analyzer = createDeadCodeAnalyzer();
      const stats = await analyzer.analyze(commits, { repoPath });
      spinner.stop();

      await handleOutput(stats, options, () => {
        let output = '';
        output += '\n';
        output += chalk.bold.gray(`  üíÄ Dead Code Detection`) + '\n';
        output += chalk.gray(`  ${'‚îÄ'.repeat(50)}`) + '\n';

        // Summary
        const s = stats.summary;
        output += `\n  ${chalk.bold('Summary:')}\n`;
        output += `    Files analyzed:      ${s.totalFilesAnalyzed}\n`;
        output += `    Dead files:          ${chalk.red(s.deadFilesCount.toString())}\n`;
        output += `    Zombie files:        ${chalk.yellow(s.zombieFilesCount.toString())}\n`;
        output += `    Duplication:         ${s.deadCodePercentage.toFixed(1)}%\n`;
        output += `    Potential savings:   ${chalk.green(s.potentialSavings)}\n`;

        // Dead files
        if (stats.deadFiles.length > 0) {
          output += chalk.bold.red(`\n  üíÄ Dead Files (not imported):`) + '\n';
          stats.deadFiles.slice(0, 10).forEach(file => {
            const filePath = file.path.length > 45 ? '...' + file.path.slice(-42) : file.path;
            const conf = file.confidence >= 80 ? chalk.red : file.confidence >= 60 ? chalk.yellow : chalk.gray;
            output += `    ${conf('‚óè')} ${filePath}\n`;
            output += `      ${chalk.gray(`${file.confidence}% confidence | ${file.daysSinceModified} days old`)}\n`;
          });
        }

        // Zombie files
        if (stats.zombieFiles.length > 0) {
          output += chalk.bold.yellow(`\n  üßü Zombie Files (single commit, old):`) + '\n';
          stats.zombieFiles.slice(0, 5).forEach(file => {
            const filePath = file.path.length > 45 ? '...' + file.path.slice(-42) : file.path;
            output += `    ${chalk.yellow('‚óè')} ${filePath}\n`;
            output += `      ${chalk.gray(`${file.daysSinceModified} days old | by ${file.author}`)}\n`;
          });
        }

        // Deprecated patterns
        if (stats.deprecatedPatterns.length > 0) {
          output += chalk.bold.red(`\n  ‚ö†Ô∏è  Deprecated Naming Patterns:`) + '\n';
          stats.deprecatedPatterns.slice(0, 5).forEach(file => {
            output += `    ${chalk.red('‚óè')} ${file.path}\n`;
            output += `      ${chalk.gray(file.reason)}\n`;
          });
        }

        // Test orphans
        if (stats.testOrphans.length > 0) {
          output += chalk.bold.yellow(`\n  üß™ Orphan Tests (no source file):`) + '\n';
          stats.testOrphans.slice(0, 5).forEach(orphan => {
            output += `    ${chalk.yellow('‚óè')} ${orphan.testFile}\n`;
            output += `      ${chalk.gray(`Expected: ${orphan.expectedSource}`)}\n`;
          });
        }

        // Recommendations
        if (stats.recommendations.length > 0) {
          output += chalk.bold(`\n  üìã Recommendations:`) + '\n';
          stats.recommendations.slice(0, 3).forEach(rec => {
            const priority = rec.priority === 'high' ? chalk.red('HIGH') :
                            rec.priority === 'medium' ? chalk.yellow('MEDIUM') : chalk.gray('LOW');
            output += `    [${priority}] ${rec.description}\n`;
            output += `      ${chalk.gray(rec.action)} | Savings: ${rec.potentialSavings}\n`;
          });
        }

        output += '\n';
        return output;
      }, renderDeadCodeHtml);
    } catch (error) {
      spinner.fail('Failed');
      console.error(chalk.red(`Error: ${(error as Error).message}`));
      process.exit(1);
    }
  });

// Dependencies command
program
  .command('dependencies')
  .description('Analyze file dependencies and detect issues')
  .argument('[path]', 'Path to the repository', '.')
  .option('-f, --file <path>', 'Save HTML report to file')
  .action(async (path: string, options: { file?: string }) => {
    showBanner();
    const repoPath = resolve(path);

    const isRepo = await isGitRepository(repoPath);
    if (!isRepo) {
      console.error(chalk.red(`Error: Not a git repository: ${repoPath}`));
      process.exit(1);
    }

    const spinner = ora('Analyzing dependencies...').start();

    try {
      const parser = createGitParser(repoPath);
      const commits = await parser.getCommits();
      const analyzer = createDependencyAnalyzer();
      const stats = await analyzer.analyze(commits, { repoPath });
      spinner.stop();

      await handleOutput(stats, options, () => {
        let output = '';
        output += '\n';
        output += chalk.bold.blue(`  üï∏Ô∏è  Dependency Analysis`) + '\n';
        output += chalk.gray(`  ${'‚îÄ'.repeat(50)}`) + '\n';

        // Summary
        const s = stats.summary;
        const healthColor = s.healthScore >= 70 ? chalk.green : s.healthScore >= 40 ? chalk.yellow : chalk.red;

        output += `\n  ${chalk.bold('Summary:')}\n`;
        output += `    Health Score:     ${healthColor(s.healthScore.toString())}/100\n`;
        output += `    Total files:      ${s.totalFiles}\n`;
        output += `    Total deps:       ${s.totalDependencies}\n`;
        output += `    Avg deps/file:    ${s.avgDependenciesPerFile.toFixed(1)}\n`;
        output += `    Circular deps:    ${chalk.red(s.circularCount.toString())}\n`;
        output += `    Hub files:        ${chalk.yellow(s.hubCount.toString())}\n`;
        output += `    Orphan modules:   ${s.orphanCount}\n`;

        // Circular dependencies
        if (stats.circularDependencies.length > 0) {
          output += chalk.bold.red(`\n  üîÑ Circular Dependencies:`) + '\n';
          stats.circularDependencies.slice(0, 3).forEach(cycle => {
            const severity = cycle.severity === 'high' ? chalk.red : cycle.severity === 'medium' ? chalk.yellow : chalk.gray;
            output += `    ${severity('‚óè')} Cycle of ${cycle.length} files:\n`;
            cycle.cycle.slice(0, 4).forEach((file, i) => {
              const shortFile = file.length > 40 ? '...' + file.slice(-37) : file;
              const arrow = i < cycle.cycle.length - 1 ? ' ‚Üí' : '';
              output += `      ${shortFile}${arrow}\n`;
            });
            output += `      ${chalk.gray(cycle.suggestion)}\n`;
          });
        }

        // Hub files
        if (stats.hubFiles.length > 0) {
          output += chalk.bold.yellow(`\n  üéØ Hub Files (high connectivity):`) + '\n';
          stats.hubFiles.slice(0, 5).forEach(hub => {
            const hubPath = hub.path.length > 40 ? '...' + hub.path.slice(-37) : hub.path;
            const typeColor = hub.type === 'hub-both' ? chalk.red : chalk.yellow;
            output += `    ${typeColor('‚óè')} ${hubPath}\n`;
            output += `      Fan-in: ${hub.fanIn} | Fan-out: ${hub.fanOut} | Type: ${hub.type}\n`;
          });
        }

        // Layer violations
        if (stats.layerViolations.length > 0) {
          output += chalk.bold.red(`\n  üèõÔ∏è  Layer Violations:`) + '\n';
          stats.layerViolations.slice(0, 5).forEach(violation => {
            output += `    ${chalk.red('‚óè')} ${violation.fromLayer} ‚Üí ${violation.toLayer}\n`;
            output += `      ${chalk.gray(violation.from.split('/').pop())} imports ${chalk.gray(violation.to.split('/').pop())}\n`;
          });
        }

        // Clusters
        if (stats.clusters.length > 0) {
          output += chalk.bold(`\n  üì¶ Module Clusters:`) + '\n';
          stats.clusters.slice(0, 5).forEach(cluster => {
            const cohesionColor = cluster.cohesion >= 0.7 ? chalk.green : cluster.cohesion >= 0.4 ? chalk.yellow : chalk.red;
            output += `    ${cluster.name.padEnd(20)} ${cluster.files.length} files | Cohesion: ${cohesionColor((cluster.cohesion * 100).toFixed(0) + '%')}\n`;
          });
        }

        // Recommendations
        if (stats.recommendations.length > 0) {
          output += chalk.bold(`\n  üìã Recommendations:`) + '\n';
          stats.recommendations.slice(0, 3).forEach(rec => {
            const priority = rec.priority === 'critical' ? chalk.red('CRITICAL') :
                            rec.priority === 'high' ? chalk.yellow('HIGH') :
                            rec.priority === 'medium' ? chalk.cyan('MEDIUM') : chalk.gray('LOW');
            output += `    [${priority}] ${rec.description}\n`;
            output += `      ${chalk.gray(rec.action)}\n`;
          });
        }

        output += '\n';
        return output;
      }, renderDependencyHtml);
    } catch (error) {
      spinner.fail('Failed');
      console.error(chalk.red(`Error: ${(error as Error).message}`));
      process.exit(1);
    }
  });

// Duplicates command
program
  .command('duplicates')
  .description('Detect duplicated and copy-pasted code')
  .argument('[path]', 'Path to the repository', '.')
  .option('-f, --file <path>', 'Save HTML report to file')
  .action(async (path: string, options: { file?: string }) => {
    showBanner();
    const repoPath = resolve(path);

    const isRepo = await isGitRepository(repoPath);
    if (!isRepo) {
      console.error(chalk.red(`Error: Not a git repository: ${repoPath}`));
      process.exit(1);
    }

    const spinner = ora('Detecting duplicates...').start();

    try {
      const parser = createGitParser(repoPath);
      const commits = await parser.getCommits();
      const analyzer = createCopyPasteAnalyzer();
      const stats = await analyzer.analyze(commits, { repoPath });
      spinner.stop();

      await handleOutput(stats, options, () => {
        let output = '';
        output += '\n';
        output += chalk.bold.magenta(`  üìã Copy-Paste Detection`) + '\n';
        output += chalk.gray(`  ${'‚îÄ'.repeat(50)}`) + '\n';

        // Summary
        const s = stats.summary;
        output += `\n  ${chalk.bold('Summary:')}\n`;
        output += `    Files analyzed:        ${s.totalFilesAnalyzed}\n`;
        output += `    Lines analyzed:        ${s.totalLinesAnalyzed.toLocaleString()}\n`;
        output += `    Duplicated lines:      ${chalk.yellow(s.duplicatedLines.toLocaleString())}\n`;
        output += `    Duplication:           ${s.duplicationPercentage.toFixed(1)}%\n`;
        output += `    Clone groups:          ${s.cloneGroupCount}\n`;
        output += `    Similar file pairs:    ${s.similarFilePairs}\n`;
        output += `    Refactoring savings:   ${chalk.green('~' + s.estimatedRefactoringSavings + ' LOC')}\n`;

        // Similar files
        if (stats.similarFiles.length > 0) {
          output += chalk.bold.yellow(`\n  üìÑ Similar Files:`) + '\n';
          stats.similarFiles.slice(0, 5).forEach(pair => {
            const f1 = pair.file1.length > 30 ? '...' + pair.file1.slice(-27) : pair.file1;
            const f2 = pair.file2.length > 30 ? '...' + pair.file2.slice(-27) : pair.file2;
            const simColor = pair.similarity >= 80 ? chalk.red : chalk.yellow;
            output += `    ${simColor('‚óè')} ${f1}\n`;
            output += `      ‚Üî ${f2} ${simColor(`(${pair.similarity}% similar)`)}\n`;
          });
        }

        // Clone groups
        if (stats.cloneGroups.length > 0) {
          output += chalk.bold.red(`\n  üîÅ Duplicate Code Blocks:`) + '\n';
          stats.cloneGroups.slice(0, 5).forEach(group => {
            output += `    ${chalk.red('‚óè')} Clone Group #${group.id} (${group.instances.length} instances, ${group.lines} lines)\n`;
            group.instances.slice(0, 3).forEach(inst => {
              const file = inst.file.length > 40 ? '...' + inst.file.slice(-37) : inst.file;
              output += `      ${file}:${inst.startLine}-${inst.endLine}\n`;
            });
            output += `      ${chalk.gray(group.suggestion)}\n`;
          });
        }

        // Pattern duplicates
        if (stats.patternDuplicates.length > 0) {
          output += chalk.bold(`\n  üîç Pattern-based Duplicates:`) + '\n';
          stats.patternDuplicates.slice(0, 3).forEach(pattern => {
            output += `    ${chalk.cyan('‚óè')} ${pattern.pattern}\n`;
            output += `      ${pattern.occurrences.length} occurrences\n`;
            output += `      ${chalk.gray(pattern.suggestion)}\n`;
          });
        }

        // Recommendations
        if (stats.recommendations.length > 0) {
          output += chalk.bold(`\n  üìã Recommendations:`) + '\n';
          stats.recommendations.slice(0, 3).forEach(rec => {
            const priority = rec.priority === 'high' ? chalk.red('HIGH') :
                            rec.priority === 'medium' ? chalk.yellow('MEDIUM') : chalk.gray('LOW');
            output += `    [${priority}] ${rec.description}\n`;
            output += `      ${chalk.gray(rec.action)} | Savings: ~${rec.estimatedSavings} LOC\n`;
          });
        }

        output += '\n';
        return output;
      }, renderDuplicatesHtml);
    } catch (error) {
      spinner.fail('Failed');
      console.error(chalk.red(`Error: ${(error as Error).message}`));
      process.exit(1);
    }
  });

// Code City command
program
  .command('city')
  .description('Generate 3D Code City visualization')
  .argument('[path]', 'Path to the repository', '.')
  .option('-f, --file <path>', 'Save 3D HTML visualization to file')
  .action(async (path: string, options: { file?: string }) => {
    showBanner();
    const repoPath = resolve(path);

    const isRepo = await isGitRepository(repoPath);
    if (!isRepo) {
      console.error(chalk.red(`Error: Not a git repository: ${repoPath}`));
      process.exit(1);
    }

    const spinner = ora('Building code city...').start();

    try {
      const parser = createGitParser(repoPath);
      const repoInfo = await parser.getRepositoryInfo();
      const commits = await parser.getCommits();
      const analyzer = createCodeCityAnalyzer();
      const stats = await analyzer.analyze(commits, { repoPath });
      spinner.stop();

      // Use custom handler for city - always CLI, and 3D HTML if file specified
      await handleOutput(stats, options, () => {
        let output = '';
        output += '\n';
        output += chalk.bold.cyan(`  üèôÔ∏è  Code City`) + '\n';
        output += chalk.gray(`  ${'‚îÄ'.repeat(50)}`) + '\n';

        // Summary
        const s = stats.summary;
        const healthColorFn = s.overallHealth >= 70 ? chalk.green : s.overallHealth >= 40 ? chalk.yellow : chalk.red;

        output += `\n  ${chalk.bold('City Overview:')}\n`;
        output += `    Overall Health:     ${healthColorFn(s.overallHealth.toString())}/100\n`;
        output += `    Districts:          ${s.totalDistricts}\n`;
        output += `    Buildings (files):  ${s.totalBuildings}\n`;
        output += `    Total LOC:          ${s.totalLOC.toLocaleString()}\n`;
        output += `    Avg building height: ${s.avgBuildingHeight.toFixed(1)}\n`;

        // Building health
        output += `\n  ${chalk.bold('Building Health:')}\n`;
        output += `    ${chalk.green('‚óè Healthy:')}  ${s.healthyBuildings}\n`;
        output += `    ${chalk.yellow('‚óè Warning:')}  ${s.warningBuildings}\n`;
        output += `    ${chalk.red('‚óè Critical:')} ${s.criticalBuildings}\n`;

        // Districts
        if (stats.city.length > 0) {
          output += chalk.bold(`\n  üèòÔ∏è  Districts:`) + '\n';
          stats.city.slice(0, 8).forEach(district => {
            const dHealthColor = district.metrics.healthScore >= 70 ? chalk.green :
                               district.metrics.healthScore >= 40 ? chalk.yellow : chalk.red;
            const activity = district.metrics.activityLevel === 'hot' ? 'üî•' :
                            district.metrics.activityLevel === 'warm' ? 'üå°Ô∏è' : '‚ùÑÔ∏è';
            output += `    ${activity} ${district.name.padEnd(20)} ${district.metrics.totalFiles} files | ${dHealthColor(district.metrics.healthScore.toFixed(0) + '/100')}\n`;
          });
        }

        // Health indicators
        if (stats.healthIndicators.length > 0) {
          output += chalk.bold(`\n  üè• Health Indicators:`) + '\n';
          stats.healthIndicators.forEach(ind => {
            const statusEmoji = ind.status === 'good' ? '‚úÖ' : ind.status === 'warning' ? '‚ö†Ô∏è' : '‚ùå';
            output += `    ${statusEmoji} ${ind.name.padEnd(18)} ${ind.value} - ${chalk.gray(ind.description)}\n`;
          });
        }

        // Tallest buildings (most complex files)
        const tallest = stats.buildings.sort((a, b) => b.height - a.height).slice(0, 5);
        if (tallest.length > 0) {
          output += chalk.bold(`\n  üè¢ Tallest Buildings (most LOC):`) + '\n';
          tallest.forEach(b => {
            const bPath = b.path.length > 40 ? '...' + b.path.slice(-37) : b.path;
            const bHealthColor = b.health === 'healthy' ? chalk.green :
                               b.health === 'warning' ? chalk.yellow : chalk.red;
            output += `    ${bHealthColor('‚óè')} ${bPath} (${b.metrics.loc} LOC)\n`;
          });
        }

        // Critical buildings
        const critical = stats.buildings.filter(b => b.health === 'critical').slice(0, 5);
        if (critical.length > 0) {
          output += chalk.bold.red(`\n  üö® Critical Buildings:`) + '\n';
          critical.forEach(b => {
            const bPath = b.path.length > 40 ? '...' + b.path.slice(-37) : b.path;
            output += `    ${chalk.red('‚óè')} ${bPath}\n`;
            b.healthReasons.slice(0, 2).forEach(reason => {
              output += `      ${chalk.gray('‚îî‚îÄ')} ${reason}\n`;
            });
          });
        }

        output += '\n';
        return output;
      }, () => renderCodeCity3D(stats, repoInfo.name));

      if (options.file) {
        console.log(chalk.gray(`   Open in browser to explore the 3D city`));
      }
    } catch (error) {
      spinner.fail('Failed');
      console.error(chalk.red(`Error: ${(error as Error).message}`));
      process.exit(1);
    }
  });

// Report command - generates all HTML reports
program
  .command('report')
  .description('Generate all HTML reports in a directory')
  .argument('[path]', 'Path to the repository', '.')
  .option('-d, --dir <directory>', 'Output directory for reports', './gitstats-report')
  .action(async (path: string, options: { dir: string }) => {
    showBanner();
    const repoPath = resolve(path);
    const outputDir = resolve(options.dir);

    const isRepo = await isGitRepository(repoPath);
    if (!isRepo) {
      console.error(chalk.red(`Error: Not a git repository: ${repoPath}`));
      process.exit(1);
    }

    // Create output directory
    const { mkdir } = await import('node:fs/promises');
    await mkdir(outputDir, { recursive: true });

    console.log(chalk.cyan(`\n  üìÅ Output directory: ${outputDir}\n`));

    const spinner = ora('Running full analysis...').start();

    try {
      // Run main analysis
      const report = await analyzeRepository({ repoPath }, (progress) => {
        spinner.text = `${progress.phase} (${progress.current}/${progress.total})`;
      });

      spinner.succeed('Analysis complete');

      // Get repo name for titles
      const repoName = report.repository.name;

      // Generate reports
      const reports = [
        { name: 'analyze', label: 'Full Analysis' },
        { name: 'velocity', label: 'Velocity' },
        { name: 'busfactor', label: 'Bus Factor' },
        { name: 'workpatterns', label: 'Work Patterns' },
        { name: 'complexity', label: 'Complexity' },
        { name: 'commits', label: 'Commit Quality' },
        { name: 'collaboration', label: 'Collaboration' },
        { name: 'coupling', label: 'Coupling' },
        { name: 'health', label: 'Health' },
        { name: 'branches', label: 'Branches' },
        { name: 'burnout', label: 'Burnout Risk' },
        { name: 'leaderboard', label: 'Leaderboard' },
        { name: 'deadcode', label: 'Dead Code' },
        { name: 'dependencies', label: 'Dependencies' },
        { name: 'duplicates', label: 'Duplicates' },
        { name: 'city', label: 'Code City 3D' },
      ];

      console.log(chalk.bold('\n  Generating reports:\n'));

      // 1. Full analyze report
      const htmlRenderer = createRenderer('html');
      const analyzeHtml = await htmlRenderer.render(report, {
        format: 'html',
        options: { pretty: true, theme: 'dark' },
      });
      await writeFile(`${outputDir}/analyze.html`, analyzeHtml);
      console.log(chalk.green(`    ‚úì analyze.html`) + chalk.gray(' - Full Analysis'));

      // 2. Velocity
      if (report.velocity) {
        await writeFile(`${outputDir}/velocity.html`, renderVelocityHtml(report.velocity));
        console.log(chalk.green(`    ‚úì velocity.html`) + chalk.gray(' - Development Velocity'));
      }

      // 3. Bus Factor
      await writeFile(`${outputDir}/busfactor.html`, renderBusFactorHtml(report.busFactor));
      console.log(chalk.green(`    ‚úì busfactor.html`) + chalk.gray(' - Bus Factor Analysis'));

      // 4. Work Patterns
      if (report.workPatterns) {
        await writeFile(`${outputDir}/workpatterns.html`, renderWorkPatternsHtml(report.workPatterns));
        console.log(chalk.green(`    ‚úì workpatterns.html`) + chalk.gray(' - Work Patterns'));
      }

      // 5. Complexity
      if (report.complexity) {
        await writeFile(`${outputDir}/complexity.html`, renderComplexityHtml(report.complexity));
        console.log(chalk.green(`    ‚úì complexity.html`) + chalk.gray(' - Code Complexity'));
      }

      // 6. Commit Quality
      if (report.commitQuality) {
        await writeFile(`${outputDir}/commits.html`, renderCommitQualityHtml(report.commitQuality));
        console.log(chalk.green(`    ‚úì commits.html`) + chalk.gray(' - Commit Quality'));
      }

      // 7. Collaboration
      if (report.collaboration) {
        await writeFile(`${outputDir}/collaboration.html`, renderCollaborationHtml(report.collaboration));
        console.log(chalk.green(`    ‚úì collaboration.html`) + chalk.gray(' - Team Collaboration'));
      }

      // 8. Coupling
      if (report.coupling) {
        await writeFile(`${outputDir}/coupling.html`, renderCouplingHtml(report.coupling));
        console.log(chalk.green(`    ‚úì coupling.html`) + chalk.gray(' - File Coupling'));
      }

      // 9. Health
      if (report.health) {
        await writeFile(`${outputDir}/health.html`, renderHealthHtml(report.health));
        console.log(chalk.green(`    ‚úì health.html`) + chalk.gray(' - Repository Health'));
      }

      // 10. Branches
      if (report.branchAnalysis) {
        await writeFile(`${outputDir}/branches.html`, renderBranchesHtml(report.branchAnalysis));
        console.log(chalk.green(`    ‚úì branches.html`) + chalk.gray(' - Branch Analysis'));
      }

      // Run additional analyzers for new reports
      const parser = createGitParser(repoPath);
      const commits = await parser.getCommits();

      // 11. Burnout
      const burnoutAnalyzer = createBurnoutAnalyzer();
      const burnout = await burnoutAnalyzer.analyze(commits, { repoPath });
      await writeFile(`${outputDir}/burnout.html`, renderBurnoutHtml(burnout));
      console.log(chalk.green(`    ‚úì burnout.html`) + chalk.gray(' - Burnout Risk'));

      // 12. Leaderboard
      const leaderboardAnalyzer = createLeaderboardAnalyzer();
      const leaderboard = await leaderboardAnalyzer.analyze(commits, { repoPath });
      await writeFile(`${outputDir}/leaderboard.html`, renderLeaderboardHtml(leaderboard));
      console.log(chalk.green(`    ‚úì leaderboard.html`) + chalk.gray(' - Contributor Leaderboard'));

      // 13. Dead Code
      const deadcodeAnalyzer = createDeadCodeAnalyzer();
      const deadcode = await deadcodeAnalyzer.analyze(commits, { repoPath });
      await writeFile(`${outputDir}/deadcode.html`, renderDeadCodeHtml(deadcode));
      console.log(chalk.green(`    ‚úì deadcode.html`) + chalk.gray(' - Dead Code Detection'));

      // 14. Dependencies
      const dependencyAnalyzer = createDependencyAnalyzer();
      const dependencies = await dependencyAnalyzer.analyze(commits, { repoPath });
      await writeFile(`${outputDir}/dependencies.html`, renderDependencyHtml(dependencies));
      console.log(chalk.green(`    ‚úì dependencies.html`) + chalk.gray(' - Dependency Analysis'));

      // 15. Duplicates
      const copypasteAnalyzer = createCopyPasteAnalyzer();
      const duplicates = await copypasteAnalyzer.analyze(commits, { repoPath });
      await writeFile(`${outputDir}/duplicates.html`, renderDuplicatesHtml(duplicates));
      console.log(chalk.green(`    ‚úì duplicates.html`) + chalk.gray(' - Code Duplicates'));

      // 16. Code City
      const cityAnalyzer = createCodeCityAnalyzer();
      const city = await cityAnalyzer.analyze(commits, { repoPath });
      await writeFile(`${outputDir}/city.html`, renderCodeCity3D(city, repoName));
      console.log(chalk.green(`    ‚úì city.html`) + chalk.gray(' - 3D Code City'));

      // Generate index.html
      const indexHtml = `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GitStats Report - ${repoName}</title>
  <style>
    :root { --bg: #1a1a2e; --card: #16213e; --text: #eaeaea; --accent: #00d9ff; --border: #2d3748; }
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: var(--bg); color: var(--text); padding: 2rem; }
    .container { max-width: 1000px; margin: 0 auto; }
    h1 { color: var(--accent); text-align: center; margin-bottom: 0.5rem; font-size: 2.5rem; }
    .subtitle { text-align: center; color: #888; margin-bottom: 2rem; }
    .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 1rem; }
    .card { background: var(--card); border-radius: 12px; padding: 1.5rem; text-decoration: none; color: var(--text); transition: transform 0.2s, box-shadow 0.2s; border: 1px solid var(--border); }
    .card:hover { transform: translateY(-4px); box-shadow: 0 8px 25px rgba(0,217,255,0.2); border-color: var(--accent); }
    .card h3 { color: var(--accent); margin-bottom: 0.5rem; display: flex; align-items: center; gap: 0.5rem; }
    .card p { color: #888; font-size: 0.9rem; }
    .footer { text-align: center; margin-top: 3rem; color: #666; font-size: 0.85rem; }
  </style>
</head>
<body>
  <div class="container">
    <h1>üìä GitStats Report</h1>
    <p class="subtitle">${repoName} - Generated ${new Date().toLocaleDateString()}</p>

    <div class="grid">
      <a href="analyze.html" class="card">
        <h3>üìà Full Analysis</h3>
        <p>Complete repository analysis with all metrics and charts</p>
      </a>
      <a href="city.html" class="card">
        <h3>üèôÔ∏è Code City 3D</h3>
        <p>Interactive 3D visualization of your codebase</p>
      </a>
      <a href="velocity.html" class="card">
        <h3>üöÄ Velocity</h3>
        <p>Development pace, trends, and release rhythm</p>
      </a>
      <a href="busfactor.html" class="card">
        <h3>üöå Bus Factor</h3>
        <p>Knowledge distribution and risk areas</p>
      </a>
      <a href="burnout.html" class="card">
        <h3>üî• Burnout Risk</h3>
        <p>Team health and work pattern analysis</p>
      </a>
      <a href="leaderboard.html" class="card">
        <h3>üèÜ Leaderboard</h3>
        <p>Top contributors and fun stats</p>
      </a>
      <a href="workpatterns.html" class="card">
        <h3>‚è∞ Work Patterns</h3>
        <p>Team habits, peak hours, and work-life balance</p>
      </a>
      <a href="complexity.html" class="card">
        <h3>üß© Complexity</h3>
        <p>Technical debt and code complexity metrics</p>
      </a>
      <a href="commits.html" class="card">
        <h3>üìù Commit Quality</h3>
        <p>Commit patterns and best practices analysis</p>
      </a>
      <a href="collaboration.html" class="card">
        <h3>ü§ù Collaboration</h3>
        <p>Team collaboration patterns and dynamics</p>
      </a>
      <a href="coupling.html" class="card">
        <h3>üîó Coupling</h3>
        <p>File coupling and hidden dependencies</p>
      </a>
      <a href="health.html" class="card">
        <h3>üè• Health</h3>
        <p>Code freshness and maintenance status</p>
      </a>
      <a href="branches.html" class="card">
        <h3>üåø Branches</h3>
        <p>Branch health, stale branches, and workflow</p>
      </a>
      <a href="deadcode.html" class="card">
        <h3>üíÄ Dead Code</h3>
        <p>Unused files and zombie code detection</p>
      </a>
      <a href="dependencies.html" class="card">
        <h3>üì¶ Dependencies</h3>
        <p>Module structure and dependency analysis</p>
      </a>
      <a href="duplicates.html" class="card">
        <h3>üìã Duplicates</h3>
        <p>Copy-paste detection and code clones</p>
      </a>
    </div>

    <p class="footer">Generated by GitStats v0.1.4</p>
  </div>
</body>
</html>`;

      await writeFile(`${outputDir}/index.html`, indexHtml);
      console.log(chalk.green(`    ‚úì index.html`) + chalk.gray(' - Report Index'));

      console.log(chalk.bold.green(`\n  ‚úÖ All reports generated successfully!`));
      console.log(chalk.cyan(`\n  üìÇ Open ${outputDir}/index.html in your browser\n`));

    } catch (error) {
      spinner.fail('Failed');
      console.error(chalk.red(`Error: ${(error as Error).message}`));
      process.exit(1);
    }
  });

// Helper function to collect multiple values
function collect(value: string, previous: string[]): string[] {
  return previous.concat([value]);
}

// Parse and execute
program.parse();
